# jQAssistant Graph RAG

This project transforms a Neo4j graph generated by jQAssistant into a semantically rich, AI-ready knowledge graph. It enriches the graph by linking compiled Java/Kotlin artifacts to their original source code and then generates multi-level, context-aware summaries for every component of the codebase, from individual methods to the entire project.

This enriched graph can be queried by AI agents and developers to gain deep insights into the software's architecture, behavior, and design.

### Example Questions it Can Help With:

*   "What is the primary responsibility of the `user-service` package?"
*   "Explain the role of the `AuthenticationController` class."
*   "Show me the key components in the `com.example.payment` directory."
*   "Help me understand the workflow for processing a new order."

## Why This Project?

[jQAssistant](https://jqassistant.org/) is a powerful tool for scanning compiled Java/Kotlin artifacts (`.jar`, `.class` files) and creating a structural graph of the codebase in Neo4j. However, this graph represents the bytecode, which lacks two critical elements for modern AI-driven analysis:

1.  **A direct link to the source code**: The graph knows about `com.example.UserService` as a compiled type but doesn't have a robust, queryable link to the `UserService.java` file where the developer's intent is actually expressed.
2.  **Semantic understanding**: A structural graph can show that a method calls another, but it doesn't explain *why*. It lacks the semantic "glue" that describes the purpose and role of each component.

This project bridges that gap. It ingests a jQAssistant graph and performs a two-stage enhancement process:

1.  **Graph Enrichment**: It automatically detects the project's root path from the graph, parses the source code, and creates a rich set of properties and relationships (`:SourceFile`, `absolute_path`, `entity_id`, `[:CONTAINS_SOURCE]`) to model the codebase accurately.
2.  **RAG Generation**: It walks the entire enriched graph in a structured, bottom-up manner, using a Large Language Model (LLM) to generate summaries for every method, type, file, directory, package, and the project itself.

The result is a powerful, multi-layered knowledge graph that combines structural accuracy with deep semantic understanding, making it an ideal foundation for advanced code analysis and AI agent interaction.

## Key Features & Design Principles

*   **Fully Automatic**: Auto-detects the project root from the graph, requiring no path configuration from the user.
*   **AI-Enriched Knowledge Graph**: Transforms a structural jQAssistant graph into a rich knowledge base with AI-generated summaries at every level of abstraction.
*   **Stable Entity Identification**: Implements a robust `entity_id` system to uniquely and stably identify every component, enabling a reliable and persistent caching mechanism.
*   **Hierarchical, Bottom-Up Summarization**: Generates summaries in a dependency-aware order, starting from methods and building up to the project level.
*   **Advanced Dependency Analysis**: Employs sophisticated graph traversal algorithms to respect complex hierarchies, such as processing base classes before the classes that inherit from them.
*   **Scalable Token Management**: Intelligently handles large source files and complex components by automatically chunking context to fit within the LLM's token limits.
*   **Incremental & Resumable Processing**: Uses a resilient caching system to track progress and avoid re-processing unchanged code, saving significant time and LLM costs on subsequent runs.
*   **Modular & Extensible Architecture**: Built with a clean separation of concerns (Orchestrator, Normalizer, Linker, Summarizers), making the system easy to understand and maintain.

## Prerequisites

*   A running Neo4j instance (v5.0+) with a graph already generated by jQAssistant.
*   Python 3.11 or higher.
*   Installation of required Python packages:
    ```bash
    pip install -r requirements.txt
    ```

## Usage

The project provides two primary tools: the main enrichment script (`main.py`) and a standalone schema analyzer (`schema_analyzer.py`).

### Main Enrichment Tool (`main.py`)

This is the main entry point for the project. It runs the full, two-phase process of enriching the graph and, optionally, generating the RAG summaries. The project path is detected automatically from the graph.

**Phase 1: Graph Enrichment (Default)**
This phase connects source files, normalizes the graph, and creates stable `entity_id`s. It is always executed.

**Phase 2: RAG Generation (Optional)**
This phase generates the AI summaries. It is triggered by the `--generate-summary` flag.

#### Basic Usage (Enrichment Only)

This command will run all the graph normalization and enrichment passes without calling an LLM.

```bash
python3 main.py
```

#### Full Usage (Enrichment + RAG Generation)

This command will perform both the enrichment and the AI summarization.

```bash
python3 main.py --generate-summary --llm-api <your_llm_api>
```

### Schema Analysis Tool (`schema_analyzer.py`)

This is a standalone utility to inspect the schema of your jQAssistant graph. It connects to the database and prints a summary of node labels and relationship types, which is useful for debugging or exploration.

```bash
python3 schema_analyzer.py
```

### Common Options

*   `--uri <neo4j_uri>`: Neo4j connection URI (default: `bolt://localhost:7687`).
*   `--user <neo4j_user>`: Neo4j username (default: `neo4j`).
*   `--password <neo4j_password>`: Neo4j password.
*   `--log-level <level>`: Set the console logging level (e.g., `DEBUG`, `INFO`; default: `INFO`).
*   `--log-file <path>`: Path to a file to store logs.
*   `--generate-summary`: **(main.py only)** Flag to enable the RAG summary generation phase.
*   `--llm-api <api_name>`: **(main.py only)** The name of the LLM API to use for summarization (e.g., `google`, `openai`, `ollama`). Required if `--generate-summary` is used.

## Documentation

For a deep dive into the project's architecture, component responsibilities, and the logic behind the hierarchical processing and iterative summarization, please see the detailed design documents:
*   **[jQAssistant Graph Architecture](./docs/jqassistant-graph-architecture.md)**
*   **[Designing for Modular and Scalable Summarization](./docs/designing-for-modular-scalable-summarization.md)**
