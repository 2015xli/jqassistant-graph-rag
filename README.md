# jQAssistant Graph RAG

This project transforms a Neo4j graph generated by jQAssistant into a semantically rich, AI-ready knowledge graph. It enriches the graph by linking compiled Java/Kotlin artifacts to their original source code and then generates multi-level, context-aware summaries for every component of the codebase, from individual methods to the entire project.

This enriched graph can be queried by AI agents and developers to gain deep insights into the software's architecture, behavior, and design.

### Example Questions it Can Help With:

*   "What is the primary responsibility of the `user-service` package?"
*   "Explain the role of the `AuthenticationController` class."
*   "Show me the key components in the `com.example.payment` directory."
*   "Help me understand the workflow for processing a new order."

## Why This Project?

[jQAssistant](https://jqassistant.org/) is a powerful tool for scanning compiled Java/Kotlin artifacts (`.jar`, `.class` files) and creating a structural graph of the codebase in Neo4j. However, this graph represents the bytecode, which lacks two critical elements for modern AI-driven analysis:

1.  **A direct link to the source code**: The graph knows about `com.example.UserService` as a compiled type but doesn't have a robust, queryable link to the `UserService.java` file where the developer's intent is actually expressed.
2.  **Semantic understanding**: A structural graph can show that a method calls another, but it doesn't explain *why*. It lacks the semantic "glue" that describes the purpose and role of each component.

This project bridges that gap. It ingests a jQAssistant graph and performs a two-stage enhancement process:

1.  **Graph Enrichment**: It parses the project's source code to create strong, reliable `[:WITH_SOURCE]` relationships between compiled types in the graph and their corresponding source files.
2.  **RAG Generation**: It walks the entire enriched graph in a structured, bottom-up manner, using a Large Language Model (LLM) to generate summaries for every method, type, file, directory, package, and the project itself.

The result is a powerful, multi-layered knowledge graph that combines structural accuracy with deep semantic understanding, making it an ideal foundation for advanced code analysis and AI agent interaction.

## Key Features & Design Principles

*   **AI-Enriched Knowledge Graph**: Transforms a structural jQAssistant graph into a rich knowledge base with AI-generated summaries at every level of abstraction.
*   **Robust Source Code Integration**: Reliably links compiled artifacts in the graph to their original `.java` and `.kt` source files, enabling source-level analysis.
*   **Hierarchical, Bottom-Up Summarization**: Generates summaries in a dependency-aware order, starting from methods and building up to the project level. This ensures that parent summaries are enriched with the context of their already-summarized children.
*   **Advanced Dependency Analysis**: Employs sophisticated graph traversal algorithms to respect complex hierarchies, such as processing base classes before the classes that inherit from them.
*   **Scalable Token Management**: Intelligently handles large source files and complex components by automatically chunking context to fit within the LLM's token limits, enabling it to scale to massive codebases.
*   **Incremental & Resumable Processing**: Uses a resilient caching system to track progress and avoid re-processing unchanged code, saving significant time and LLM costs on subsequent runs.
*   **Modular & Extensible Architecture**: Built with a clean separation of concerns (Orchestrator, Summarizers, Processor), making the system easy to understand, maintain, and extend.

## Prerequisites

*   A running Neo4j instance (v5.0+) with a graph already generated by jQAssistant.
*   Python 3.11 or higher.
*   Installation of required Python packages:
    ```bash
    pip install -r requirements.txt
    ```

## Usage

The primary entry point is `main.py`, which provides two main commands: `enrich` and `analyze-schema`.

### Main Command: `enrich`

This command performs the full, two-phase process of enriching the graph and generating the RAG summaries.

**Phase 1: Graph Enrichment (Required)**
This phase connects source files to the graph. It is always executed.

**Phase 2: RAG Generation (Optional)**
This phase generates the AI summaries. It is triggered by the `--generate-summary` flag.

#### Basic Usage (Enrichment Only)

This command will connect the source code to the existing jQAssistant graph without calling an LLM.

```bash
python3 main.py enrich /path/to/your/project
```

#### Full Usage (Enrichment + RAG Generation)

This command will perform both the enrichment and the AI summarization.

```bash
python3 main.py enrich /path/to/your/project --generate-summary --llm-api <your_llm_api>
```

### Utility Command: `analyze-schema`

This command connects to the database and prints its schema, which can be useful for debugging or understanding the graph structure.

```bash
python3 main.py analyze-schema
```

### Common Options

*   `--uri <neo4j_uri>`: Neo4j connection URI (default: `bolt://localhost:7687`).
*   `--user <neo4j_user>`: Neo4j username (default: `neo4j`).
*   `--password <neo4j_password>`: Neo4j password.
*   `--log-level <level>`: Set the console logging level (e.g., `DEBUG`, `INFO`; default: `INFO`).
*   `--log-file <path>`: Path to a file to store logs.
*   `--generate-summary`: Flag to enable the RAG summary generation phase.
*   `--llm-api <api_name>`: The name of the LLM API to use for summarization (e.g., `google`, `openai`, `ollama`). Required if `--generate-summary` is used.

## Interacting with the Graph

Once the graph is fully enriched with summaries and embeddings, it becomes a powerful asset for various tools. You can connect a graph visualization tool like Bloom to explore the relationships, or build an AI agent (e.g., using Google's ADK or LangChain) that can query the graph to answer complex questions about your codebase in natural language.

## Documentation

For a deep dive into the project's architecture, component responsibilities, and the logic behind the hierarchical processing and iterative summarization, please see the detailed design document:
*   **[Designing for Modular and Scalable Summarization](./docs/designing-for-modular-scalable-summarization.md)**