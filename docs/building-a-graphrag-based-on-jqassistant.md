# Building a GraphRAG System Based on jQAssistant

## 1. Introduction

### 1.1. Purpose

This document details the design and architecture of a system that enriches the software dependency graph generated by jQAssistant with AI-powered analysis, summaries, and vector embeddings. The ultimate goal is to create a comprehensive and queryable knowledge graph of a software project, enabling advanced code understanding, impact analysis, and conversational code exploration. This system is referred to as a Graph-based Retrieval Augmented Generation (GraphRAG) system.

### 1.2. Core Technologies

-   **jQAssistant:** An open-source code analysis tool that scans software projects and stores the discovered structural information as a graph in a Neo4j database. It provides the foundational, factual graph of the codebase.
-   **Neo4j:** A native graph database used to store and query the software graph. Its powerful query language, Cypher, is ideal for traversing complex code relationships.
-   **Large Language Models (LLMs):** AI models are used to generate human-readable summaries and analyses of code entities, transforming raw code into understandable concepts.
-   **Embedding Models:** These models convert textual summaries into numerical vectors (embeddings). By storing these embeddings in the graph, we can perform semantic searches to find code entities based on conceptual similarity.

## 2. System Architecture

The system operates as a multi-stage pipeline that progressively enriches the initial graph provided by jQAssistant.

### 2.1. Data Flow

1.  **Scan:** A target software project is scanned by jQAssistant.
2.  **Store:** The raw output is imported into a Neo4j database, creating a graph of nodes (e.g., `:File`, `:Type`, `:Method`) and relationships (`:CONTAINS`, `:INVOKES`).
3.  **Enrich:** A series of Python scripts, orchestrated by `GraphOrchestrator` and `RagOrchestrator`, execute a sequence of "passes" to clean, link, analyze, and summarize the graph data.
4.  **Query:** The final, enriched graph, containing summaries and embeddings, is ready for semantic search and analysis.

### 2.2. Core Components

-   **`GraphOrchestrator`:** Executes initial passes that normalize, structure, and link the raw jQAssistant data. These passes do not involve AI and prepare the graph for analysis.
-   **`RagOrchestrator`:** Executes the AI-driven passes. It coordinates a series of specialized summarizer modules that generate analyses, summaries, and embeddings.
-   **Summarizer Modules:** Each module (e.g., `TypeSummarizer`, `DirectorySummarizer`) is a self-contained unit responsible for a specific summarization pass. It encapsulates its own logic for data fetching, parallel processing, and database updates.
-   **`PromptManager`:** A centralized module that contains all LLM prompt templates, decoupling the prompt engineering from the application logic.
-   **LLM & Embedding Clients:** Interfaces to external AI services or local models.

### 2.3. Parallel Processing Architecture

To accelerate the time-consuming process of making LLM calls, the system employs a parallel processing architecture tailored to the workload of each pass.

-   **I/O-Bound Tasks (Summarization):** For passes that call external LLM APIs, a `ThreadPoolExecutor` is used. This is managed by a `BaseSummarizer` class, which provides a reusable framework for processing batches of nodes (e.g., methods, types) in parallel. This is efficient for I/O-bound work as threads can switch context while waiting for network responses.
-   **CPU-Bound Tasks (Embeddings):** For the embedding generation pass, which uses a local `sentence-transformers` model, a sequential approach is used to maximize single-GPU throughput. This avoids the overhead of multi-processing when the primary resource is a single accelerator.

## 3. The Enrichment Pipeline: A Detailed Pass Design

The enrichment process is broken down into sequential passes, where each pass builds upon the data created by the previous ones.

### Part 1: Graph Normalization and Linking (`GraphOrchestrator`)

These initial passes clean and structure the raw jQAssistant data to make it robust and easier to process.

---

#### **Pass 001: Source File Linker**

-   **Purpose:** To connect abstract code entities (`:Type` nodes) to the physical files (`:File` nodes) where they are defined.
-   **Process:**
    1.  Uses `tree-sitter` to parse all `.java` and `.kt` source files in the project directory.
    2.  For each file, it extracts the package name and the fully qualified names (FQNs) of all top-level types declared within it.
    3.  It then executes a Cypher query to find the `:Type` node for each FQN and the `:File` node for the corresponding file path.
    4.  Finally, it creates a `[:WITH_SOURCE]` relationship from the `:Type` node to its containing `:File` node.
-   **Output:** A graph where `:Type` nodes are directly linked to the `:File` nodes that contain their source code.

---

#### **Pass 010: Normalize Paths and Establish Project Root**

-   **Purpose:** To standardize all file paths with an `absolute_path` property and create a single root `:Project` node.
-   **Process:**
    1.  Creates a single `:Project` node for the codebase.
    2.  Identifies directory-based `:Artifact` nodes and labels them as `:Entry` points, linking them to the `:Project` node.
    3.  Sets the `absolute_path` property on each `:Entry` node to its `fileName`.
    4.  For all `:File` and `:Directory` nodes contained within an `:Entry` node (but not within a JAR), it constructs an `absolute_path` by concatenating the entry's path with the node's relative `fileName`.
-   **Output:** A graph with a clearly defined `:Project` root and consistent, absolute paths on all file-system-related nodes.

---

#### **Pass 020: Identify and Label Source Files**

-   **Purpose:** To explicitly label files that contain source code.
-   **Process:** Finds all `:File` nodes whose `absolute_path` ends with `.java` or `.kt` and adds a `:SourceFile` label to them.
-   **Output:** `:File` nodes for source code are now also labeled as `:SourceFile`.

---

#### **Pass 030: Establish Direct Source Hierarchy**

-   **Purpose:** To create a clean, hierarchical view of the source code structure using a single relationship type.
-   **Process:** Creates `[:CONTAINS_SOURCE]` relationships to form a tree from the `:Project` node down through `:Directory` nodes to other `:Directory` and `:SourceFile` nodes. This provides a traversable file system hierarchy that ignores non-source files.
-   **Output:** A browsable source code hierarchy using the `[:CONTAINS_SOURCE]` relationship.

---

#### **Pass 035: Link Members to Source Files**

-   **Purpose:** To extend the source linking from types down to their members (`:Method` and `:Field`).
-   **Process:** For each `:Method` and `:Field`, it traverses to its parent `:Type`, finds the `:SourceFile` linked to that type, and creates a direct `[:WITH_SOURCE]` relationship from the member to that same file.
-   **Output:** `:Method` and `:Field` nodes are now directly linked to the file containing their source code, enabling easy code extraction.

---

### Part 2: RAG Generation (`RagOrchestrator`)

These passes leverage LLMs to generate rich semantic information. Each pass is encapsulated in its own module with a `run()` method that handles its specific execution strategy.

---

#### **Pass 040: Method Code Analysis (`MethodAnalyzer`)**

-   **Purpose:** To generate a detailed, technical analysis of what each method's code does.
-   **Execution Strategy:** Single pass. Fetches all methods at once and processes them in parallel.
-   **Process:**
    1.  Finds all `:Method` nodes that are linked to a `:SourceFile` and do not yet have a `code_analysis` property.
    2.  For each method, it extracts the raw code snippet from the source file using its stored line numbers.
    3.  It sends the code snippet to the LLM with a prompt asking for a detailed technical breakdown.
    4.  The LLM's explanation is stored in the `code_analysis` property on the `:Method` node.
-   **Output:** Each `:Method` node receives a `code_analysis` property.

---

#### **Pass 041: Method Contextual Summary (`MethodSummarizer`)**

-   **Purpose:** To generate a concise summary of a method's *purpose* and *role*.
-   **Execution Strategy:** Single pass. Processes all methods with a `code_analysis` in parallel.
-   **Process:**
    1.  Finds all `:Method` nodes that have a `code_analysis` but no `summary`.
    2.  For each method, it gathers context: its `code_analysis`, the names of methods that invoke it (callers), and the names of methods it invokes (callees).
    3.  This contextual information is sent to the LLM with a prompt asking for a summary of the method's role.
-   **Output:** Each `:Method` node receives a `summary` property.

---

#### **Pass 050: Type Summaries (`TypeSummarizer`)**

-   **Purpose:** To summarize classes, interfaces, and enums based on their members and inheritance hierarchy.
-   **Execution Strategy:** Iterative, dependency-based. The `run()` method loops, processing batches of types until no more can be summarized. This correctly handles the complex graph of inheritance.
-   **Process (per iteration):**
    1.  Finds all `:Type` nodes that do not have a `summary` and whose in-project parent types (classes/interfaces they extend/implement) *do* have summaries. This ensures a bottom-up approach.
    2.  For each qualifying type, it gathers context: summaries of its declared methods and summaries of its parent types.
    3.  This aggregated information is sent to the LLM to generate a holistic summary.
-   **Output:** Each `:Type` node receives a `summary` property.

---

#### **Pass 060: Source File Summaries (`SourceFileSummarizer`)**

-   **Purpose:** To summarize entire source files.
-   **Execution Strategy:** Single pass. Processes all source files whose contents have been fully summarized.
-   **Process:**
    1.  Finds all `:SourceFile` nodes that do not have a `summary` and where all contained `:Type` nodes *do* have summaries.
    2.  For each file, it gathers the summaries of all types declared within it.
    3.  It asks the LLM to synthesize these type summaries into a file-level summary.
-   **Output:** Each `:SourceFile` node receives a `summary` property.

---

#### **Pass 070: Directory Summaries (`DirectorySummarizer`)**

-   **Purpose:** To summarize directories, providing an overview of the components they contain.
-   **Execution Strategy:** Hierarchical, depth-first. The `run()` method fetches all directories, groups them by path depth, and processes them in loops from the deepest level to the shallowest.
-   **Process (per level):**
    1.  For each directory at the current depth, it gathers the summaries of its direct children (`:SourceFile`s and sub-directories).
    2.  It asks the LLM to create a summary for the directory based on its children's summaries.
-   **Output:** Each `:Directory` node receives a `summary` property.

---

#### **Pass 080: Package Summaries (`PackageSummarizer`)**

-   **Purpose:** To summarize Java/Kotlin packages.
-   **Execution Strategy:** Hierarchical, depth-first. Similar to directories, it processes packages from the most deeply nested to the top-level.
-   **Process (per level):**
    1.  For each package at the current depth, it gathers the summaries of its contained `:Type`s and sub-packages.
    2.  It asks the LLM to create a summary for the package based on this context.
-   **Output:** Each `:Package` node receives a `summary` property.

---

#### **Pass 100: Project Summary (`ProjectSummarizer`)**

-   **Purpose:** To create a high-level, executive summary of the entire project.
-   **Execution Strategy:** Single pass. Runs after all other summaries are complete.
-   **Process:** It gathers the summaries of the top-level packages and directories and asks the LLM to generate a final project overview.
-   **Output:** The `:Project` node receives a `summary` property.

---

#### **Pass 110: Add Entity Label and Embeddings (`EntityEmbedder`)**

-   **Purpose:** To prepare the graph for semantic search by generating vector embeddings.
-   **Execution Strategy:** Single pass, sequential processing to optimize for a single GPU.
-   **Process:**
    1.  Adds an `:Entity` label to every node that has a `summary` property.
    2.  Fetches all `:Entity` nodes that do not yet have a `summaryEmbedding`.
    3.  Processes the nodes in batches:
        a.  Sends the `summary` of each node in the batch to a local `sentence-transformers` model.
        b.  Stores the resulting numerical vector in a `summaryEmbedding` property on the node.
    4.  Ensures a vector index named `summary_embeddings` exists in Neo4j for efficient similarity searches on the `summaryEmbedding` property.
-   **Output:** All summarized nodes are labeled as `:Entity` and have a vector `summaryEmbedding` property. A vector index is created.