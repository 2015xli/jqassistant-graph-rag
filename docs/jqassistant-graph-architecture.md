# Understanding the jQAssistant Graph Architecture

This document details the architecture of the Neo4j graph generated by jQAssistant and the semantic layer our project builds on top of it. A correct and deep understanding of this architecture is fundamental to the success of the GraphRAG enrichment project. This document aims to capture the complexities, subtleties, and design decisions involved.

## 1. Core Concepts: Structural vs. Semantic Graph

jQAssistant scans compiled artifacts and creates a **structural graph** in Neo4j. This graph is an excellent representation of the bytecode, but it lacks two key features for AI-driven analysis: a direct link to the source code and a semantic understanding of each component's purpose.

Our project's goal is to build a **semantic layer** on top of this structural graph. We do this by:
1.  **Enriching** the graph with new nodes, properties, and relationships that model the source code structure accurately.
2.  **Generating** AI summaries for each component, creating a rich, multi-layered knowledge graph suitable for Retrieval-Augmented Generation (RAG).

## 2. Key jQAssistant Node Labels (The Structural Layer)

### `:Artifact`
- **The Container**: An `:Artifact` node is the root of a scanned resource, acting as a container or "virtual file system" for a hierarchy of packages and types.
- **Dual Nature**: An `:Artifact` is typically either:
    1.  A **directory** on the file system (labeled `:Artifact:Directory:File`).
    2.  A **JAR file** (labeled `:Artifact:Jar:Archive:File`).
- **`fileName` Property**: This property's meaning is highly context-dependent.
    - For a directory artifact, `fileName` is the absolute path to that directory.
    - For a JAR artifact, `fileName` is the absolute path to the `.jar` file.

### `:File`, `:Directory`, and `:Package`
- **Overlapping and Ambiguous Labels**:
    - A `:Directory` node always has a `:File` label.
    - A `:Package` node always has a `:Directory` label.
    - jQAssistant often labels any directory within a source tree as a `:Package`, even if it isn't a true Java/Kotlin package, creating ambiguity.
- **`fileName` Property Nuances**:
    - For nodes within a **JAR artifact**, `fileName` is the path *inside* the JAR (e.g., `/com/example/MyClass.class`).
    - For nodes within a **directory artifact**, `fileName` is the path relative to that artifact's root, but with a leading `/`. This can be confusing and necessitates normalization.

### `:Type`
- **Represents a `.class` file**: This node represents a compiled type. It is often specialized with labels like `:Class`, `:Interface`, etc.
- **`fqn` (Fully Qualified Name)**: This property (e.g., `com.example.MyClass`) is the type's logical identifier. **Crucially, it is not guaranteed to be unique.** A project might include two different JARs that both contain a class with the same FQN.
- **`sourceFileName`**: This property often holds just the simple name of the source file (e.g., `MyClass.java`), making it insufficient for locating the file.

### `:Member` (`:Method`, `:Field`)
- **Owned by a `:Type`**: These nodes represent methods and fields. They do not have an `fqn` or `fileName` property.
- **Identification**: They are identified by their `signature` and can only be uniquely located by first finding the `:Type` that `DECLARES` them.

## 3. Key jQAssistant Relationship Types

### `[:CONTAINS]`
- **Transitive and Non-Hierarchical**: This is the most complex relationship. An `:Artifact` node will have a `[:CONTAINS]` relationship to *all* nodes within its virtual file system, no matter how deeply nested. This makes it unsuitable for traversing a direct parent-child hierarchy.

### `[:DECLARES]`, `[:EXTENDS]`, `[:IMPLEMENTS]`, `[:INVOKES]`
- These relationships model the logical code structure: type ownership, inheritance, and method calls. They are the primary connectors of the structural graph.

## 4. The GraphRAG Enrichment Layer

Our project adds a semantic layer to the graph to resolve the ambiguities of the structural layer. This is done through a series of **normalization passes**.

### The `:Project` Node
- We create a single `:Project` node to act as the absolute root of the analysis. Its `name` and `absolute_path` are determined automatically from the graph's `:Artifact` nodes.

### The `absolute_path` Property
- To resolve the ambiguity of `fileName`, we add a consistent `absolute_path` property to all file-system-like nodes (`:File`, `:Directory`, `:SourceFile`). This path is the canonical, unambiguous location of the file or directory on the file system.

### The `:SourceFile` Label
- We introduce a dedicated `:SourceFile` label for all `.java` and `.kt` files. This clearly distinguishes them from other nodes with the `:File` label (like directories or `.class` files in JARs).

### The `[:CONTAINS_SOURCE]` Relationship
- To bypass the problematic `[:CONTAINS]` relationship, we create our own clean, direct, parent-child hierarchy using `[:CONTAINS_SOURCE]`. This allows for reliable traversal of the source code's directory structure.

### The `:Entity` Label and `entity_id` Property
- **This is the cornerstone of our identification and caching strategy.**
- **Problem**: Neo4j's internal `elementId` is unstable between runs, and simple properties like `fqn` are not unique.
- **Solution**: We create a new `entity_id` property for every node relevant to summarization. This ID is a stable, unique MD5 hash generated from a composite key that guarantees uniqueness. We also add an `:Entity` label to all such nodes and enforce a database uniqueness constraint on `entity_id`.

#### `entity_id` Generation Logic:
- **For `:Project`**: Hash of its `name`.
- **For `:Artifact`**: Hash of its `fileName` (its absolute path).
- **For `:File`, `:Directory`, `:Package`, `:Type`**: Hash of the string `"{Artifact.fileName}::{Node.fileName}"`. This scopes the node to its containing artifact, solving the uniqueness problem.
- **For `:Member` (`:Method`, `:Field`)**: Hash of the string `"{Artifact.fileName}::{Type.fileName}::{Member.signature}"`. This scopes the member to its parent type and containing artifact.

This `entity_id` becomes the canonical identifier used for all caching, dependency tracking, and data retrieval during the summarization process, ensuring the stability and correctness of the entire system.