# Specification of the graph architecture of the jQAssistant-based GraphRAG

This document details the architecture of the Neo4j graph generated by jQAssistant and the semantic layer our project builds on top of it. A correct and deep understanding of this architecture is fundamental to the success of the GraphRAG enrichment project. This document aims to capture the complexities, subtleties, and design decisions involved.

## 1. Core Concepts: Structural vs. Semantic Graph

jQAssistant is basically designed around .jar files. It can be used also for .class files, but requires that they are arranged in strict package structure. It is surely not designed for normal source tree, while a graphRAG mainly needs source tree for code analysis. jQAssistant's class graph and our source tree graph are complementary for the graphRAG. But we need know the difference.

jQAssistant scans compiled artifacts and creates a **structural graph** in Neo4j. This graph is an excellent representation of the bytecode, but it lacks two key features for AI-driven analysis: a direct link to the source code and a semantic understanding of each component's purpose.

Our project's goal is to build a **semantic layer** on top of this structural graph. We do this by:
1.  **Enriching** the graph with new nodes, properties, and relationships that model the relationships between the source code and class hierarchy accurately.
2.  **Generating** AI summaries for each component, creating a rich, multi-layered knowledge graph suitable for Retrieval-Augmented Generation (RAG).

## 2. Key jQAssistant Node Labels

  3. So I'd suggest the following way to compute the entity_id, using the following string to compute md5 hash id:
  3.1. For :Artifact node, just fileName. (The absolute path for entry directory of Jar file.)
  3.2. For all :File nodes (including :File:Directory and :File) under :Artifact:Directory (which CONTAINS the :File node), 
  use the Artifact node's fileName + the File node's own fileName. 
  3.3. For all :File nodes (including :File:Package and :File:Type, and other :File nodes) under :Artifact:Jar (which 
  CONTAINS those :File nodes), use the Artifact node's fileName + the File node's own fileName.
  Since fileName of Artifact nodes are unique, and fileName within an Artifact container is unique. We can get unique string
   for all of them.
  3.4. For :Member nodes (including :Member:Method and :Member:Field) of :Type, they don't have fileName. We should get 
  their fileName from the parent Type node that declares them, and the Artifact node that CONTAINS the parent Type node. 
  Basically we use the unique string of their parent Type node (Artifact fileName + Type fileName) + their own's signature. 
  Since their signature is unique within a Type, the ensures the Member nodes have unique string.
  3.5. For :Project node, we can use its "Project" + {project_path} as the unique string, since the project_path can be the 
  same as the fileName of :Artifact:Directory is it is the only Artifact in the project.
  This is a very consistent way to get the unique string, and then we compute with MD5 to get an unique entity ID. We can do
   this even at the inital pass after Project node is created, at the same time, we can create Entity label the nodes with 
  entity_id. After Entity label is created, we can also set neo4j unique constraint for Entity's entity_id property. Current
   Entity is set only for nodes with summary, which is necessarily strict.

### `:Artifact`

- **The Container**: An `:Artifact` node is the root of a scanned resource, acting as a container (of a "virtual file system") for a hierarchy of packages and types (like Class, Interface, etc).
- **Dual Nature**: An `:Artifact` node is typically either:
    1.  A **directory** on the file system (labeled `:Artifact:Directory:File`). The nodes under the :Artifact:Directory node are arranged in the same way as the file system. One higher level :Directory:File node CONTAINS its direct sub-dir :Directory:File nodes, and its direct sub-file nodes :File nodes. The :Artifact:Directory node _directly_ CONTAINS all of the transitive descendent :Directory:File and :File nodes, i.e., the :Artifact:Directory node _directly_ CONTAINS all of the descendents in its container "virtual file system". 
    2.  A **JAR file** (labeled `:Artifact:Jar:Archive:File`). The nodes under the :Artifact:Jar node are arranged in the same way of the package structure in the JAR file. One higher level :Package:Directory nodes CONTAINS its direct sub-package :Package:Directory nodes, and its direct sub class file :Type:File nodes, and also non-package sub-dir :Directory:File nodes for META-INF/, etc.. The :Artifact:Jar node _directly_ CONTAINS all of the transitive descendent :Package:Directory:File, :Type:File, and some other kinds of nodes, i.e., the :Artifact:Jar node _directly_ CONTAINS all of the descendents in its container "virtual file system". 
    3. Cross-container nodes: A directory :Artifact node may :CONTAINS a jar file in its source directory tree. The jar file is an :Artifact:Jar node. In this case, the :Directory:Artifact node :CONTAINS the :Artifact:Jar node, _directly_ and _indirectly_ through the directory tree structure. But, the :Directory:Artifact node does not :CONTAINS the descendent nodes of the :Artifact:Jar node, i.e., the :Artifact containership does not cross the boundary of its contained :Artifact node. They are two independent "virtual file systems", except that the :Artifact:Jar node is contained in the "virtual file system" of the :Directory:Artifact node.

### `:File`, `:Directory`, and `:Package`
- **:Directory:File**: A `:Directory` node always has a `:File` label, since :Directory is a special kind of :File node, but not vice versa.

- **Overlapping Labels**: jQAssistant often (though not always) labels the directory starting from an :Artifact node as a `:Directory:Package`, even if it is not a true package structure. As we've mentioned above, jQAssistant is designed around "package-structured" system, either a Jar file or a directory with a "package-structured" directory tree. Then it is easy to understand the following:
    - A `:Package` node always has a `:Directory` label, since :Package is a special kind of :Directory node, but not vice versa.
    - A `:Type` node always has a `:File` label, since :Type is represented by a .class file. But a `:File` is not always a :Type node, since :File can be a directory or a jar file.

### `fileName` Property: 
This property's meaning is highly context-dependent. 

- **Filename-Rule-1: Directly scanned nodes**: Only the jQAssistant directly scanned :Artifact nodes' `fileName` is the absolute path of the directory or the jar file. Other nodes within a container do not have absolute path.
    - **Filename-Rule-1.1**: For a `:Artifact:Directory` node, `fileName` is the absolute path to that directory. For example, `/entry_directory/path`
    - **Filename-Rule-1.2**: For a `:Artifact:Jar` node, if the jar file is directly scanned, then the `fileName` is the absolute path to the `.jar` file. E.g., `/entry_directory/path/util/tools/data.jar`
- **Filename-Rule-2: `:File` nodes' in jar files**: For nodes within a `:Artifact:Jar` container, `fileName` is the path *inside* the JAR, which is the same as the package structure in the JAR. E.g., `/java/data/Data.class`
- **Filename-Rule-3: `:File` nodes' in directory files**: For a `:File` node (including both :Directory:File and :File) within a `:Artifact:Directory` container, `fileName` is the relative path (with leading `/`) to the `:Artifact:Directory` node. This is because jQAssistant basically treats the scanned directory tree as a package-structured directory tree. E.g., if the :Artifact:Directory node is `/entry_directory/path`, and the file is `/entry_directory/path/util/tools/src/java/data/Data.class`, then the `fileName` of the :File node is `/util/tools/src/java/data/Data.class`
    - **Filename-Rule-3.1: Indirectly scanned jar files**: According to Filename-Rule-3, if a jar file is indirectly scanned because it is in a scanned directory, it is a :File node in a `:Artifact:Directory` container, so the `fileName` of the `:Artifact:Jar` node is relative path to the `:Artifact:Directory` node that contains the jar file. E.g., if the :Artifact:Directory node is `/entry_directory/path`, and the jar file is `/entry_directory/path/util/tools/data.jar`, then the `fileName` of the `:Artifact:Jar` node is `/util/tools/data.jar`


### `:Type`
- **Represents a `.class` file**: It is a `:File` node, also has `:Type` label. It is often specialized with labels like `:Class`, `:Interface`, `Enum`, etc.
- **`Annotation` is not a :Type**: `:Annotation` is not a `:Type` node, whose `:Type` can be accessed through `:TYPE_OF` relationship.
- **`sourceFileName`**: This property often holds just the simple name of the source file (e.g., `MyClass.java`), making it insufficient for locating the original source file.

### `:Member` (`:Method`, `:Field`)
- **Owned by a `:Type`**: These nodes represent methods and fields. They do not have an `fqn` or `fileName` property.
- **Identification**: They are identified by their `signature` and can only be located by first finding the `:Type` that `DECLARES` them.

### `fqn` (Fully Qualified Name) proptery of :Package and :Type nodes: 
- **FQN-Rule-1: fqn of a .class file**: It is the true fully qualified name, is unique within its ancestor `Jar:Artifact` node's container (without crossing :Jar container boundary). A jQAssistant graph can have multiple same .class files in different `:Artifact` containers, or even multiple same .class files in different sub-dir trees of the same `:Directory:Artifact` container. They all have the same `fqn`. That means, `fqn` is not unique to identify a class file or :Type node. 
- **FQN-Rule-2: fqn of a `:Directory` node**: For a normal directory under a `:Artifact:Directory` container, it is treated as a package node (as we mentioned more than once), so it also has `fqn` property. Its `fqn` is the same as its `fileName` property, just replacing `"/"` with `"."` (after removing the leading `"/"`). Since different `:Artifact:Directory` nodes can have sub-dir nodes with the same `fileName`, they will have the same `fqn`. 
For example, a `:Artifact:Directory` node have `fileName` `"/entry_directory/path"`, and it has a descendent sub-dir 
`"/entry_directory/path/util/tools/src/java/data/"`, then this subdir's `:Directory` node for the leaf directory `"data"` has `fileName` 
`"/util/tools/src/java/data"` and `fqn` `"util.tools.src.java.data"`, although this is not a real package structure. 
- **FQN-Rule-3: fqn of a `:File` node**: 
  - If an `:Artifact:Directory` node contains a `:File` node that is for a non-class file, such as a .java file. It has no `fqn`, but `fileName` like "/util/tools/src/java/data/Data.java". 
  - If an `:Artifact:Directory` node contains a `:File` node that is for a class file, such as a .class file. It has `fqn`. But its `fqn` is its true FQN (according to FQN-Rule-1), not the `fileName`. For example, its `fileName` can be "/util/tools/src/java/data/Data.class", but its `fqn` is `"java.data.Data"`. 



## 3. Key jQAssistant Relationship Types

### `[:CONTAINS]`
- **Transitive and Non-Hierarchical from an `:Artifact` node**: An `:Artifact` node will have a `[:CONTAINS]` relationship to *all* nodes within its container "virtual file system", no matter how deeply nested. 
- **Hierarchical from a node within a container**: On the other hand, the nodes within the container only have `[:CONTAINS]` relationship to their direct children, not their grandchildren.
- **No cross-container `[:CONTAINS]` relationship**: An `:Artifact` node of a container will not have `[:CONTAINS]` relationship to nodes in other containers. Even if a `:Artifact:Directory` node `[:CONTAINS]` a `:Artifact:Jar` node, the former `:Artifact:Directory` node will not have `[:CONTAINS]` relationship to the nodes within the latter `:Artifact:Jar` container.

### `[:DECLARES]`, `[:EXTENDS]`, `[:IMPLEMENTS]`, `[:INVOKES]`
- These relationships model the logical code structure: type-member ownership, type-type relationships (inheritance, implementation, etc.), and method calls. They are the primary connectors of the structural graph.

## 4. The GraphRAG Enrichment Layer

Our project adds a semantic layer to the graph. This is done through a series of **normalization passes**.

### The `:Project` Node
- To simplify the multiple graph entrances of `:Artifact` nodes, we create a single `:Project` node to act as the absolute root of the analysis. Its `name` and `absolute_path` can be determined automatically from the graph's `:Artifact` nodes.

### The `absolute_path` Property
- To resolve the problem of context-sensitive `fileName` property, we add a consistent `absolute_path` property to all file-system-like nodes (`:File`, `:Directory`, `:SourceFile`). This path is the canonical, unambiguous location of the file or directory on the file system.

### The `:SourceFile` Label
- To resolve the ambiguity of `:File` label on all kinds of `:Directory`, `:Package`, `:Type`, and `:File` nodes, we introduce a dedicated `:SourceFile` label for all `.java` and `.kt` source files. This clearly distinguishes them from other nodes with the `:File` label.

### The `[:CONTAINS_SOURCE]` Relationship
- To bypass the problematic `[:CONTAINS]` relationship, we create our own clean, direct, parent-child hierarchy using `[:CONTAINS_SOURCE]` for the directory tree related to source files. This allows AI agent to traverse the source code's directory structure and conduct intellegent analysis.

### The `:Entity` Label and `entity_id` Property
- jQAssistant graph does not have a stable, unique identifier for nodes, so we create a new `entity_id` property for every node relevant to graphRAG. This ID is a stable, unique MD5 hash generated from a composite key that guarantees uniqueness. We also add an `:Entity` label to all such nodes and enforce a database uniqueness constraint on `entity_id`.

#### `entity_id` Generation Logic:
- **For `:Project`**: Hash of its `"project://" + project_path`.
- **For `:Artifact`**: Hash of its `fileName` (its absolute path).
- **For `:File`, `:Directory`, `:Package`, `:Type`**: Hash of the string `"{Artifact.fileName} + {Node.fileName}"`. This scopes the node to its containing artifact, solving the uniqueness problem.
- **For `:Member` (`:Method`, `:Field`)**: Hash of the string `"{Artifact.fileName} + {Type.fileName} + {Member.signature}"`. This scopes the member to its parent type and containing artifact.

This `entity_id` becomes the canonical identifier used for all caching, dependency tracking, and data retrieval during the summarization and analysis process, ensuring the stability and correctness of the entire system.
