# Specification of the graph architecture of the jQAssistant-based GraphRAG

This document details the architecture of the Neo4j graph generated by jQAssistant and the semantic layer our project builds on top of it. A correct and deep understanding of this architecture is fundamental to the success of the GraphRAG enrichment project. This document aims to capture the complexities, subtleties, and design decisions involved.

## 1. Core Concepts: Structural vs. Semantic Graph

jQAssistant is basically designed around compiled artifacts like .jar, .war, and .ear files. It can be used also for .class files, but requires that they are arranged in strict package structure. It is surely not designed for normal source tree, since a graphRAG mainly needs source tree for code analysis. jQAssistant's class graph and our source tree graph are complementary for the graphRAG. But we need know the difference.

jQAssistant scans compiled artifacts and creates a **class structural graph** in Neo4j. This graph is an excellent representation of the bytecode, but it lacks two key features for AI-driven analysis: a direct link to the source code and a semantic understanding of each component's purpose.

Our project's goal is to build a **code semantic layer** on top of this structural graph. We do this by:
1.  **Enriching** the graph with new nodes, properties, and relationships that model the relationships between the source code and class hierarchy accurately.
2.  **Generating** AI summaries for each component, creating a rich, multi-layered knowledge graph suitable for Retrieval-Augmented Generation (RAG).

## 2. Key jQAssistant Node Labels

### `:Artifact`

- **The Container**: An `:Artifact` node is the root of a scanned resource, acting as a container (of a "virtual file system") for a hierarchy of packages and types (like Class, Interface, etc). 
    - As mentioned above, jQAssistant requires the scanned resource to be well arranged in package/class hierarchy structure, either a directory or a jar/war/ear file, that can be deployed/used as a classpath. 
    - If it is a directory with class files, the directory should be scanned with the `java:classpath::` prefix followed by the path to the directory: `jQAssistant scan -f java:classpath::<path_to_directory>`. Otherwise, the class files in the directory will not be parsed by jQAssistant. 
- **Dual Nature**: An `:Artifact` node is typically either:
    1.  A **directory** on the file system (labeled `:Artifact:Directory:File`). The nodes contained under the `:Artifact:Directory` node are arranged in the same way as the file system. One higher level `:Directory:File` node CONTAINS its direct sub-dir `:Directory:File` nodes, and its direct sub-file `:File` nodes. The `:Artifact:Directory` node _directly_ `CONTAINS` all of the transitive descendent `:Directory:File` and `:File` nodes, i.e., the `:Artifact:Directory` node _directly_ CONTAINS all of the descendents in its container "virtual file system".
    By default, jQAssistant assumes all of the descedent nodes are either `:Package` or `:Type` (and some other build artifact's specific labels, like `ResourceLoader`.)  Note: the problem here is, if you use jQAssistant to scan a directory (with `java:classpath::` prefix) that is not structured as package/class hierarchy as the build artifacts, jQAssistant still treats it as it is structured as a package/class hierarchy. This cause issues like a source code directory node has `:Package` label and `fqn` property, which are obviously wrong.   
    2.  A **JAR/WAR/EAR file (we use JAR file as an example)** (labeled `:Artifact:Jar:Archive:File`). The nodes contained under the `:Artifact:Jar` node are arranged in the same way of the package structure in the jar file. One higher level `:Package:Directory` nodes `CONTAINS` its direct sub-package `:Package:Directory` nodes, and its direct sub class file `:Type:File` nodes, (and also some non-package/type nodes existing in the jar file, such as for `META-INF/`,) etc. The `:Artifact:Jar` node _directly_ `CONTAINS` all of the transitive descendent `:Package:Directory:File`, `:Type:File`, and other kinds of nodes, i.e., the `:Artifact:Jar` node _directly_ `CONTAINS` all of the descendents in its container "virtual file system". 
- **Cross-container nodes**: A directory `:Artifact:Directory` node may `:CONTAINS` a jar file in its directory tree. The jar file is an `:Artifact:Jar` node. In this case, the `:Artifact:Directory` node `:CONTAINS` the `:Artifact:Jar` node, both _directly_ and _transitively_ through the directory tree structure. But, the `:Artifact:Directory` node does not `:CONTAINS` the descendent nodes of the `:Artifact:Jar` node, i.e., the `:Artifact` containership does not cross the boundary of its contained `:Artifact` node. They are two independent "virtual file systems", except that the root node the `:Artifact:Jar` "virtual file system" is contained in its parent "virtual file system". That is, if you pick off the `:Artifact:Jar` node from the parent "virtual file system", all its descendent nodes will be removed too from the parent "virtual file system".

### `:File`, `:Directory`, and `:Package`
- **:Directory:File**: A `:Directory` node always has a `:File` label, since `:Directory` is a special kind of `:File` node, but not vice versa.

- **Overlapping Labels**: As described above, when you scan a direcrory or jar file (with prefix `java:classpath::`), jQAssistant will label it as a build artificat package/class hierarchy structure. The directories starting from an `:Artifact` node are labeled as `:Directory:Package`, even if it is not a true package structure. Then it is easy to understand the following:
    - A `:Package` node always has a `:Directory` label, since :Package is a special kind of `:Directory` node, but not vice versa.
    - A `:Type` node always has a `:File` label, since `:Type` is represented by a .class file. But a `:File` is not always a `:Type` node, since `:File` can be a jar file, a source file, or even a directory.

### `fileName` Property: 
This property's meaning is highly context-dependent. 

- **Filename-Rule-1: Directly scanned nodes**: Only the jQAssistant directly scanned `:Artifact` nodes' `fileName` is the absolute path (of the directory or the jar file). Other nodes within a container do not have absolute path.
    - **Filename-Rule-1.1**: For a `:Artifact:Directory` node, `fileName` is the absolute path of that directory. For example, `/entry_directory/path`
    - **Filename-Rule-1.2**: For a `:Artifact:Jar` node, if the jar file is directly scanned, then the `fileName` is the absolute path of the `.jar` file. E.g., `/entry_directory/path/util/tools/data.jar`
- **Filename-Rule-2: `:File` nodes' in jar files**: For nodes within a `:Artifact:Jar` container (including both `:Directory:File` and `:File`), `fileName` is the path *inside* the JAR, which is the same as the package structure in the JAR. E.g., `/java/data/Data.class`
- **Filename-Rule-3: `:File` nodes' in directory files**: For a `:File` node (including both `:Directory:File` and `:File`) within a `:Artifact:Directory` container, `fileName` is the relative path (with leading `/`) to the `:Artifact:Directory` node. This is because jQAssistant treats the scanned directory tree as a package-structured directory tree. E.g., if the `:Artifact:Directory` node is `/entry_directory/path`, and the file is `/entry_directory/path/util/tools/src/java/data/Data.class`, then the `fileName` of the `:File` node is `/util/tools/src/java/data/Data.class`
    - **Filename-Rule-3.1: Indirectly scanned jar files**: According to Filename-Rule-3, if a jar file is indirectly scanned because it is in a scanned directory, it is a `:File` node in a `:Artifact:Directory` container, so the `fileName` of the `:Artifact:Jar` node is relative path to the `:Artifact:Directory` node that contains the jar file. E.g., if the `:Artifact:Directory` node is `/entry_directory/path`, and the jar file is `/entry_directory/path/util/tools/data.jar`, then the `fileName` of the `:Artifact:Jar` node is `/util/tools/data.jar`. For the `:File` nodes inside the `:Artifact:Jar` container, their `fileName` applies the same rule as Filename-Rule-2.
**Filename-Rule-4: `fileName` is not unique in the graph**: The root node (`:Artifact`) of different containers use absolute paths as their `fileName` properties, which are unique. Within a container, the `fileName` is the "relative path" to the root of the container, and it is not unique across different containers. We cannot use `fileName` to uniquely identify a `:Directory` or `:File` node.

### `:Type`
- **Represents a `.class` file**: It is a `:File` node, also has `:Type` label. It is often specialized with labels like `:Class`, `:Interface`, `Enum`, etc.
- **`Annotation` is not a :Type**: `:Annotation` is not a `:Type` node, whose `:Type` can be accessed through `:TYPE_OF` relationship.
- **`sourceFileName`**: This property often holds just the simple name of the source file (e.g., `MyClass.java`), making it insufficient for locating the original source file.

### `:Member` (`:Method`, `:Field`)
- **Owned by a `:Type`**: These nodes represent methods and fields. They do not have an `fqn` or `fileName` property.
- **Identification**: They are identified by their `signature` and can only be located by first finding the `:Type` that `DECLARES` them.

### `fqn` (Fully Qualified Name) proptery of :Package and :Type nodes: 
- **FQN-Rule-1: fqn of a .class file**: The `fqn` of a class file is always the class's fully qualified name. 
    * If the class file is within a `:Artifact:Jar` container, its `fqn` is unique within the `:Artifact:Jar` node's container (i.e., without crossing `:Artifact` container boundary). 
    * When the class file is within a `:Artifact:Directory` container, if the directory is indeed a classpath directory (with package/class hierarchy), its `fqn` is unique within the container. If the directory is a general project path, then the `fqn` may not be unique in the container, because a `:Artifact:Directory` contained directory tree may have multiple copies of same class files in different sub-directories. They all have the same `fqn`. This means, `fqn` is not unique to identify a class file or `:Type` node within an `:Artifact:Directory` container, unless it strictly follows the package/class hierarchy. 
    * Even if the `fqn` is unique within an `:Aritifact:Jar` container, it may not be unique across different `:Artifact` (including `:Artifact:Jar` and `:Artifact:Directory`) containers, because different `:Artifact` containers may have the same class files with the same `fqn`. That means, `fqn` is not unique to identify a class file or `:Type` node in a jQAssistant graph. 
- **FQN-Rule-2: fqn of a `:Directory` node**: For a normal directory under a `:Artifact:Directory` container, it is treated as a package node (as we've mentioned more than once), so it also has `fqn` property. Its `fqn` is the same as its `fileName` property, just replacing `"/"` with `"."` (after removing the leading `"/"`). As stated in Filename-Rule-4, `fileName` is not unique to identify a `:Directory` in a jQAsssistant graph, nor is the `fqn`. 
For example, a `:Artifact:Directory` node has `fileName` `"/entry_directory/path"`, and it has a descendent sub-dir 
`"/entry_directory/path/util/tools/src/java/data/"`, then this subdir's `:Directory` node has `fileName` 
`"/util/tools/src/java/data"` and `fqn` `"util.tools.src.java.data"`. 
- **FQN-Rule-3: `fqn` of a `:File` node**: 
  - If an `:Artifact:Directory` node contains a `:File` node that is for a non-class file, such as a `.java` file. It has no `fqn`, but `fileName` with relative path like "/util/tools/src/java/data/Data.java". 
  - If an `:Artifact:Directory` node contains a `:File` node that is for a class file. It has `fqn`, which is its true FQN (according to FQN-Rule-1), not the same as its `fileName` (by replacing `"/"` with `"."`). For example, its `fileName` can be "/util/tools/src/java/data/Data.class", but its `fqn` is `"java.data.Data"`. 
- **FQN-Rule-4: `fqn` is not unique in the graph**: according to FQN-Rule-1 and FQN-Rule-2, fqn is not unqiue in the graph to identify a node, either a `:Package:Directory` or a `:Type:File` node.

## 3. Key jQAssistant Relationship Types

### `[:CONTAINS]`
- **Transitive and Non-Hierarchical from an `:Artifact` node**: An `:Artifact` node will have a `[:CONTAINS]` relationship to *all* nodes within its container "virtual file system", no matter how deeply nested. 
- **Hierarchical from a node within a container**: On the other hand, the nodes within the container only have `[:CONTAINS]` relationship to their direct children, not their grandchildren.
- **No cross-container `[:CONTAINS]` relationship**: An `:Artifact` node of a container will not have `[:CONTAINS]` relationship to nodes in other containers. Even if a `:Artifact:Directory` node `[:CONTAINS]` a `:Artifact:Jar` node, the former `:Artifact:Directory` node will not have `[:CONTAINS]` relationship to the nodes within the latter `:Artifact:Jar` container.

### `[:DECLARES]`, `[:EXTENDS]`, `[:IMPLEMENTS]`, `[:INVOKES]`
- These relationships model the logical code structure: type-member ownership, type-type relationships (inheritance, implementation, etc.), and method calls. They are the primary connectors of the structural graph.

## 4. The GraphRAG Enrichment Layer

Our project adds a semantic layer to the graph. This is done through a series of **normalization passes**.

### The `:Project` Node
- To simplify the multiple graph entrances of `:Artifact` nodes, we create a single `:Project` node to act as the absolute root of the analysis. Its `name` and `absolute_path` can be determined automatically from the graph's `:Artifact` nodes.

### The `absolute_path` Property
- To resolve the problem of context-sensitive `fileName` property, we add a consistent `absolute_path` property to all file-system-like nodes (`:File`, `:Directory`, `:SourceFile`). This path is the canonical, unambiguous location of the file or directory on the file system.

### The `:SourceFile` Label
- To resolve the ambiguity of `:File` label on all kinds of `:Directory`, `:Package`, `:Type`, and `:File` nodes, we introduce a dedicated `:SourceFile` label for all `.java` and `.kt` source files. This clearly distinguishes them from other nodes with the `:File` label.

### The `[:CONTAINS_SOURCE]` Relationship
- To bypass the problematic `[:CONTAINS]` relationship, we create our own clean, direct, parent-child hierarchy using `[:CONTAINS_SOURCE]` for the directory tree related to source files. This allows AI agent to traverse the source code's directory structure and conduct intellegent analysis.


### The `fqn` Property Normalization
- **Problem**: As described in FQN-Rule-2, jQAssistant incorrectly assigns an `fqn` property to `:Directory` nodes within a `:Directory:Artifact` by simply replacing slashes in the `fileName` with dots. This is often semantically incorrect, as a source directory structure does not always map to a package structure.
- **Solution**: We implement a sophisticated "anchor and validate" heuristic.
    1.  We find a deeply nested `:Class` file within the artifact, as it is most likely to reveal the full package path.
    2.  We use this class's correct, bytecode-derived `fqn` as a ground truth to infer the expected package directory structure.
    3.  We then validate this inferred structure by walking up the actual `:Directory` hierarchy in the graph.
    4.  If the directory names match the package components, we have found a valid package tree. We label its root as a `:ClassTree` and then run a pass to correct the `fqn` properties of all its sub-directories based on their path relative to the `:ClassTree` root.

### The `:Package` Label Normalization
- **Problem**: jQAssistant often applies a `:Package` label to any `:Directory` node inside a scanned artifact, even if it's just a normal folder in a source tree. This leads to semantic inconsistency.
- **Solution**: After building the clean `[:CONTAINS_CLASS]` hierarchy (which only connects validated package directories), we perform a final cleanup pass. We run a single Cypher query that finds any node with a `:Package` label that does *not* have an incoming `[:CONTAINS_CLASS]` relationship. For these nodes, we remove both the incorrect `:Package` label and any lingering `fqn` property. This ensures that a node is only labeled `:Package` if it is a true, validated member of a class hierarchy.

### The `:Entity` Label and `entity_id` Property
- jQAssistant graph does not have a stable, unique identifier for nodes, so we create a new `entity_id` property for every node relevant to graphRAG. This ID is a stable, unique MD5 hash generated from a composite key that guarantees uniqueness. We also add an `:Entity` label to all such nodes and enforce a database uniqueness constraint on `entity_id`.

#### `entity_id` Generation Logic:
- **For `:Project`**: Hash of its `"project://" + project_path`.
- **For `:Artifact`**: Hash of its `fileName` (its absolute path).
- **For `:File`, `:Directory`, `:Package`, `:Type`**: Hash of the string `"{Artifact.fileName} + {Node.fileName}"`. This scopes the node to its containing artifact, solving the uniqueness problem.
- **For `:Member` (`:Method`, `:Field`)**: Hash of the string `"{Artifact.fileName} + {Type.fileName} + {Member.signature}"`. This scopes the member to its parent type and containing artifact.

This `entity_id` becomes the canonical identifier used for all caching, dependency tracking, and data retrieval during the summarization and analysis process, ensuring the stability and correctness of the entire system.

